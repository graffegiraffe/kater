#include <iostream>
#include <vector> //
#include <cmath>
using namespace std;

int main() {
    system("chcp 1251"); //делаем так, чтобы компьютер распознавал русские буквы
    double change;
    double sizeA, sizeB;  //создаем переменные для размеров множества А и В
    int sizeUn = 100; //создаем размер универсального множества Un
    double size_per = 0; //создаем переменную для размера множества пересесчения
    double size_ob = 0; // создаем переменную для размера множества объединения
    double size = 0; //Создадим переменную для дальнейшего указания размера
    bool flag = false;  //устанавливаем флаг ложным для дальнейшего использования
    double x = 1; //создаем переменну для заполнения высказыванием
    vector<double> Un(sizeUn); //создаем универсальное множество определенного размера
    for (double i = 0; i < sizeUn; i++) { //Прогоняем универсальное множество
        Un[i] = i+1; //Записываем элементы в универсальное множество
    }
    cout << "Введите мощность множества А: "; //просим ввести размер множества А
    cin >> sizeA; //вводим размер множества А
    vector<double> arrayA(sizeA); //содаем массив\множество А определенного размера
    cout << "Введите мощность множества В: "; //просим ввести размер множества В
    cin >> sizeB; //вводим размер множества В
    vector<double> arrayB(sizeB); //содаем массив\множество В определенного размера
    cout << "Выберите, как задать множество (1 - вручную, 2 - высказыванием): ";
    cin >> change;
    if (change == 2) {
        cout << "A: ";
        for (double i = 0; i < sizeA; i++) {
            arrayA[i] = pow(x, 2) - x + 1;
            x++;
            cout << arrayA[i] << " ";
        }
        cout << endl;
        x = 1;
        cout << "B: ";
        for (double i = 0; i < sizeB; i++) {
            arrayB[i] = abs((pow(x, 2) - 3));
            x++;
            cout << arrayB[i] << " ";
        }
        cout << endl;
    }
    if (change == 1) {
        cout << "Вводите элементы множества А: "; //просим ввести все элементы множества А
        for (double i = 0; i < sizeA; i++) { //создаем цикл for для того, чтобы ввести все значения в массив\множество А
            cin >> arrayA[i]; //вводим занчения множества А
        }
        cout << "Вводите элементы множества В: "; //просим ввести все элементы множества В
        for (double i = 0; i < sizeB; i++) { //создаем цикл for для того, чтобы ввести все значения в массив\множество В
            cin >> arrayB[i]; //вводим занчения множества В
        }
    }
    cout << "------------------------------------------------------------------------" << endl;

    //ПЕРЕСЕЧЕНИЕ

    double n = 0; //создаем переменную n, которая будет указывать положение элементам
    for (double i = 0; i < sizeB; i++) { //через цикл for прогоняем все элементы множества В
        for (double j = 0; j < sizeA; j++) { //для каждого элемента множества В мы делаем прогон всех элементов множества А
            if (arrayB[i] == arrayA[j]) { //проверяем, равен ли элемент множества А элементу множества В, если равен, то выполняем следующее
                size_per++; //увеличиваем переменную размера массива пересечения на 1
                break; //прерываем цикл перебора элементов А для определенного элемента В, т. к. нужный элемент найден
            }
        }
    }
    vector<double> P(size_per); //создаем массив Р пересечения с размером size_per
    for (double i = 0; i < sizeB; i++) {                 ///////////////////////////////////////////////////////////////////////
        for (double j = 0; j < sizeA; j++) {             //опять прогоняем элементы двух множеств для проверки, если равны, то//
            if (arrayB[i] == arrayA[j]) {                ///////////////////////////////////////////////////////////////////////
                P[n] = arrayB[i];   //в место массива под номером переменной n передаем элемент множества В
                n++; //увеличиваем переменную n на 1 для нового места в массиве
                break; //прерываем цикл перебора элементов А для определенного элемента В, т. к. нужный элемент найден
            }
        }
    }

    //ОБЪЕДИНЕНИЕ

    for (double i = 0; i < sizeB; i++) { //через цикл for прогоняем все элементы множества В
        for (double j = 0; j < sizeA; j++) { //для каждого элемента множества В мы делаем прогон всех элементов множества А
            if (arrayA[j] == arrayB[i]) { //если элементы двух множеств равны, то выполняется следующее
                flag = false; //значение флага остается ложно
                break; //прерываем цикл перебора элементов А для определенного элемента В, т. к. элемент есть в двух множествах
            }
            else { //если элементы не равны друг другу, то выполнить следующее
                flag = true; //сделать флаг истинным
            }
        }
        if (flag) { //елси флаг истинный, то выполнить условие
            size_ob++; //размер множества объединения увеличивается на 1
        }
    }
    size_ob += sizeA; //прибавляем к текущему размеру множества объединения размер множества А, т. к. все его элементы войдут в объединение
    vector<double> M(size_ob); //создаем массив М объединения с размером size_ob

    for (double i = 0; i < sizeA; i++) { //прогоняем все множество А через цикл for
        M[i] = arrayA[i]; //записываем каждый элемент множества А во множество объединения
    }
    n = sizeA; //выставляем номер записи элемента на sizeА, потому что до него все элементы заняты
    for (double i = 0; i < sizeB; i++) {                            //////////////////////////////////////////////////////////////////////////////////////////
        for (double j = 0; j < sizeA; j++) {                        //опять для каждого элемента множества В прогоняем элементы множества В и если равны, то//
            if (arrayA[j] == arrayB[i]) {                           //////////////////////////////////////////////////////////////////////////////////////////
                flag = false; //делаем флаг ложным
                break; //прекращаем прого элементов А для этого элемента множества В, поскольку такой элемент уже есть в объединении
            }
            else { //если не равны, то выполнить условие
                flag = true; //делаем флаг истинным
            }
        }
        if (flag) { //если флаг истинный, то выполняется условие
            M[n] = arrayB[i]; //элемент множества В записывается во множество объединения под номером n
            n++; //номер n увеличивается на 1
        }
    }

    cout << "1. Множество объединения: ";
    for (double i = 0; i < size_ob; i++) { //прогоняем множество объединения
        cout << M[i] << " "; //выводим каждый элемент множества объединения
    }
    cout << endl << "2. Множество пересечения: ";
    for (double i = 0; i < size_per; i++) { //прогоняем множество пересечения
        cout << P[i] << " "; // выводим каждый элемент множества пересечения
    }

    //РАЗНОСТЬ В\А

    n = 0; //Задаем переменной размер нуль.
    for (double i = 0; i < sizeB; i++) { //Прогоняем все элементы множества В
        for (double j = 0; j < sizeA; j++) { //Для каждого элемента В прогоняем элементы А
            if (arrayB[i] == arrayA[j]) { //Если элементы равны, то выполним условие
                flag = false; //флаг делаем ложным
                break; //останавливаем перебор элементов А для текущего элемента В
            }
            else { //Если элементы не равны, то
                flag = true; //флаг делаем истинным
            }
        }
        if (flag) { //Если флаг истинный, то
            size++; //Увеличим размер на 1
        }
    }
    vector<double> RaznB_A(size); //Создадим множество разности В\А

    for (double i = 0; i < sizeB; i++) { //Переберм все элементы В
        for (double j = 0; j < sizeA; j++) { //Для каждого элемента В переберем элементы А
            if (arrayB[i] == arrayA[j]) { //Если элементы равны, то
                flag = false; //делаем флаг ложным
                break; //оканчиваем перебор элементов А для элемента В
            }
            else { //если элементы не равны, то
                flag = true; //делаем флаг истинным
            }
        }
        if (flag) { //если флаг истинный, то
            RaznB_A[n] = arrayB[i]; //заносим элемент В мо множество разности В\А
            n++; //увеличиваем номер на 1
        }
    }

    double size_raznBA = size; //создадим переменную для указания размера разности В\А
    cout << endl << "3. Множество разности В\\А: ";
    for (double i = 0; i < size; i++) { //переберм элементы разности В\А
        cout << RaznB_A[i] << " "; //выведем каждый элемент
    }

    //РАЗНОСТЬ А\В

    n = 0; //обнулим параметр
    size = 0; //обнулим параметр
    for (double i = 0; i < sizeA; i++) { //переберем все элементы А
        for (double j = 0; j < sizeB; j++) { //для каждого элемента А переберем элементы В
            if (arrayA[i] == arrayB[j]) { //если элементы равны, то
                flag = false; //флаг делаем ложным
                break; //оканчиваем перебор элементов В для элемента А
            }
            else { //если не равны
                flag = true; //делаем флаг истинным
            }
        }
        if (flag) { //если флаг истинный
            size++; //увеличим размер на 1
        }
    }
    vector<double> RaznA_B(size); //создадим множество разности А\В определенного размера

    for (double i = 0; i < sizeA; i++) { //переберем элементы множества А
        for (double j = 0; j < sizeB; j++) { //для кажого элемента множества А переберем элементы В
            if (arrayA[i] == arrayB[j]) { //если элементы равны
                flag = false; //делаем флаг ложным
                break; //оканчиваем перебор элементов В для элемента А
            }
            else { //если не равны
                flag = true; //делаем флаг истинным
            }
        }
        if (flag) { //если флаг истинный
            RaznA_B[n] = arrayA[i]; //хаписываем элемент А во множество разности А\В
            n++; //увеличиваем номер на 1
        }
    }

    double size_raznAB = size; //создаем переменную с размером разности А\В
    cout << endl << "4. Множество разности A\\B: ";
    for (double i = 0; i < size; i++) { //перебираем все элементы разности А\В
        cout << RaznA_B[i] << " "; //выводим элементы разности А\В
    }

    //СИММЕТРИЧЕСКАЯ РАЗНОСТЬ
    double size_simrazn = size_raznBA + size_raznAB; //создаем элементы симметрической разности и записываем размеры двух разнойстей
    vector<double> SimRazn(size_simrazn); //содзадим множество сим разности данного размера
    size = size_raznBA; //передадим размер разности В\А
    n = 0; //обнуим параметр
    for (double i = 0; i < size; i++) { //прогоним множество сим разности
        SimRazn[i] = RaznB_A[n]; //передадим все элементы разности В\А в сим разность
        n++; //увеличим номер на 1
    }
    n = 0; //обнулим параметр
    for (double i = size; i < size_simrazn; i++) { //прогоним множество сим разности
        SimRazn[i] = RaznA_B[n]; //передадим все элементы разности А\В сим разности
        n++; //увеличим номер на 1
    }

    cout << endl << "5. Множество симметрической разности множеств А, В: ";
    for (double i = 0; i < size_simrazn; i++) { //прогоним все элементы сим разности
        cout << SimRazn[i] << " "; //выведем все элементы сим разности
    }

    //ДЕКАРТОВО ПРОИЗВЕДЕНИЕ АхВ

    cout << endl << "6. Декартово произведение АхВ: ";
    for (double i = 0; i < sizeA; i++) { //прогоним все элементы множества А
        for (double j = 0; j < sizeB; j++) { //для каждого элемента А прогоним элементы В
            cout << "<" << arrayA[i] << ", " << arrayB[j] << "> "; //выведем каждый элемент декартова произведения АхВ
        }
    }

    //ДЕКАРТОВО ПРОИЗВЕДЕНИЕ ВхА

    cout << endl << "7. Декартово произвдение ВхА: ";
    for (double i = 0; i < sizeB; i++) { //прогоним все элементы множества В
        for (double j = 0; j < sizeA; j++) { //для каждого элемента В прогоним элементы А
            cout << "<" << arrayB[i] << ", " << arrayA[j] << "> "; //выведем каждый элемент декартова произведения ВхА
        }
    }

    // ДОПОЛНЕНИЕ А

    size = 0; //обнулим размер
    for (double i = 0; i < sizeUn; i++) { //прогоним все элементы универсального множества
        for (double j = 0; j < sizeA; j++) { //для каждого элемента ун мн переберем элементы А
            if (Un[i] == arrayA[j]) { //если элементы равны
                flag = false; //флаг делаем ложным
                break; //оканчиваем перебор элементов А для элемента ун мн
            }
            else { //если не равны
                flag = true; //делаем флаг истинным
            }
        }
        if (flag) { //если флаг истинный
            size++; //увеличим размер на 1
        }
    }
    n = 0; //обнулим параметр
    vector<double> doplA(size); //создадим множество дополнения А
    for (double i = 0; i < sizeUn; i++) { //переберем все элементы ун мн
        for (double j = 0; j < sizeA; j++) { //для каждого элемента ун мн перебере элементы А
            if (Un[i] == arrayA[j]) { //если элементы равны
                flag = false; //делаем флаг ложным
                break; //оканчиваем перебор элементов А для элемента ун мн
            }
            else { //если не равны
                flag = true; //делаем флаг истинным
            }
        }
        if (flag) { //если флаг истинный
            doplA[n] = Un[i]; //добавляем элемент ун мн в дополнение А
            n++; //увеличиваем размер на 1
        }
    }

    cout << endl << "8. Дополнение множества А: ";
    for (double i = 0; i < size; i++) { //прогоняем все элементы дополнения А
        cout << doplA[i] << " "; //выводим все элементы дополнения А
    }

    // ДОПОЛНЕНИЕ B

    size = 0; //обнуляем параметр
    for (double i = 0; i < sizeUn; i++) { //прогоняем все элементы ун мн
        for (double j = 0; j < sizeB; j++) { //длля каждого элемента ун мн прогоняем элементы В
            if (Un[i] == arrayB[j]) { //если элементы равны
                flag = false; //делаем флаг ложным
                break; //оканчиваем перебор элементов В для элемента ун мн
            }
            else { //если не равны
                flag = true; //делаем флаг истинным
            }
        }
        if (flag) { //если флаг истинный
            size++; //увеличиваем размер на 1
        }
    }
    n = 0; //обнуляем параметр
    vector<double> doplB(size); //создаем множество дополнения В
    for (double i = 0; i < sizeUn; i++) { //прогоняем элементы ун мн
        for (double j = 0; j < sizeB; j++) { //для каждого элемента ун мн прогоняем элементы В
            if (Un[i] == arrayB[j]) { //есл элементы равны
                flag = false; //флаг ложный
                break; //оканчиваем перебор элементов В для элемента ун мн
            }
            else { //если не равны
                flag = true; //флаг истинный
            }
        }
        if (flag) { //если флаг истинный
            doplB[n] = Un[i]; //заносим элемент ун мн в дополнение В
            n++; //увеличиваем размер на 1
        }
    }

    cout << endl << "9. Дополнение множества B: ";
    for (double i = 0; i < size; i++) { //перебираем все элементы дополнения В
        cout << doplB[i] << " "; //выводим элементы дополнения В
    }
    return 0;
}