#include <iostream>
#include <cmath>
using namespace std;

int main() {
	system("chcp 1251"); //Выставляю русский язык
	int num_A, num_B, f_num, s_num; // задаю переменные для размера А, В и ввода элементов пары
	cout << "Введите размерность графика А: ";
	cin >> num_A; //задаю размер графика А
	cout << "Введите размерность графика В: ";
	cin >> num_B; //задаю размер графика В
	int** A = new int* [num_A]; //создаю график А
	cout << "Вводите элементы пар для графика А:\n";
	for (int i = 0; i < num_A; i++) { //прогоняю по длине графика А
		cout << "Введите " << i + 1 << "-ую пару элементов: ";
		cin >> f_num >> s_num; //задаю первый и второй элементы пары графика А
		A[i] = new int[2]; //создаю пространство под пару в графике
		A[i][0] = f_num; //записываю первый элемент пары
		A[i][1] = s_num; //записываю второй элемент пары
	}
	int** B = new int* [num_B]; //создаю график В
	cout << "Вводите элементы пар для графика В:\n";
	for (int i = 0; i < num_B; i++) { //прогоняю по длине графика В
		cout << "Введите " << i + 1 << "-ую пару элементов: ";
		cin >> f_num >> s_num; //задаю первый и второй элементы пары графика В
		B[i] = new int[2]; //создаю пространство под пару в графике
		B[i][0] = f_num; //записываю первый элемент пары
		B[i][1] = s_num; //записываю второй элемент пары
	}
	int f_un = 1;
	int s_un = 1;
	int** Un = new int* [10000];    //Создаем универсум
	for (int i = 0; i < 10000; i++) { //прогоняем по длине универсума
		Un[i] = new int[2]; //отводим в универсуме места под пары
		/*if (s_un > 100) {
			f_un++;
			s_un = 1;
			Un[i][0] = f_un;
			Un[i][1] = s_un;
		}
		else {
			Un[i][0] = f_un;
			Un[i][1] = s_un;
			s_un++;
		}*/
	}
	int length = 0;
	for (int i = 1; i < 101; i++) {
		for (int j = 1; j < 101; j++) {
			Un[length][0] = i;
			Un[length][1] = j;
			length++;
		}
	}
	for (int i = 0; i < num_A; i++) { //прогоняем по длине графика А
		Un[i][0] = A[i][0]; //записываем первый элемент пары графика А в универсум
		Un[i][1] = A[i][1]; //записываем второй элемент пары графика А в универсум
	}
	bool flag = false; //создаем ложный флаг
	int num_Un = num_A; //создаем переменную размера универсума и передаем ей размер графика А
	for (int i = 0; i < num_B; i++) { //прогоняем по длине графика В
		for (int j = 0; j < num_A; j++) { //одновременно прогоняем по длине графика А
			if ((B[i][0] == A[j][0]) && (B[i][1] == A[j][1])) { //если первый элемент равен первому, а второй - второму
				flag = false; //делаем флаг ложным
				break; //прекращаем перегонку по графику А и берем след элемент графика В
			}
			else { // если не равны
				flag = true; //делаем флаг истинным
			}
		}
		if (flag) { //если в конце флаг истинный
			Un[num_Un][0] = B[i][0]; //записываем первый элемент пары графика В в универсум
			Un[num_Un][1] = B[i][1]; //записываем второй элемент пары графика В в универсум
			num_Un++; //увеличиваем размер универсума на 1
		}
	}

	//ОБЪЕДИНЕНИЕ
	int** M = new int* [1]; //создаем график под объединение
	flag = false; //делаем флаг ложным
	cout << "-----------ОБЪЕДИНЕНИЕ----------------\n";
	for (int i = 0; i < num_A; i++) { //прогоняем по длине А
		cout << A[i][0] << " " << A[i][1] << endl; //Выводим все элементы графика А

	}
	for (int i = 0; i < num_B; i++) { //прогоняем по длине В
		for (int j = 0; j < num_A; j++) { //одновременно прогоняем по длине В
			if ((B[i][0] == A[j][0]) && (B[i][1] == A[j][1])) { //если первый элемент равне первому, а второй - второму
				flag = false; // делаем флаг ложным
				break; //оканчиваем перебор графика А и берем след пару графика В
			}
			else { //если иначе
				flag = true; //делаем флаг истинным
			}
		}
		if (flag) { //если в конце флаг истинный
			cout << B[i][0] << " " << B[i][1] << endl; //выводим пару графика В
		}
	}

	//ПЕРЕСЕЧЕНИЕ
	cout << "-------------ПЕРЕСЕЧЕНИЕ-------------\n";
	int** P = new int* [1]; //создаем график под объединение
	for (int i = 0; i < num_A; i++) { //прогоняем по длине А
		for (int j = 0; j < num_B; j++) { //прогоняем по длине В
			if ((A[i][0] == B[j][0]) && (A[i][1] == B[j][1])) { //если первый элемент равне первому, а второй - второму
				cout << A[i][0] << " " << A[i][1] << endl; //выводим элемент
				break; //оканчиваем перебор В и берем след пару А
			}
		}
	}

	//РАЗНОСТЬ В\А
	cout << "---------------РАЗНОСТЬ В\\А----------------\n";
	flag = false; //делаем флаг ложным
	int** R1 = new int* [1]; //создаем график под разность В\А
	for (int i = 0; i < num_B; i++) { //прогоняем по длине В
		for (int j = 0; j < num_A; j++) { //прогоняем по длине А
			if ((B[i][0] == A[j][0]) && (B[i][1] == A[j][1])) { //если первый элемент равен первому, а второй - второму
				flag = false; //делаем флаг ложным
				break; //прекращаем перебор А и берем след пару В
			}
			else { //если иначе 
				flag = true; //делаем флаг истинным
				continue; //продолжаем перебор
			}
		}
		if (flag) { //если в конце флаг истинный
			cout << B[i][0] << " " << B[i][1] << endl; //то выводи пару графика В
		}
	}

	//РАЗНОСТЬ A\B
	cout << "---------------РАЗНОСТЬ A\\B----------------\n";
	flag = false; //делаем флаг ложным
	int** R2 = new int* [1]; //создаем график по дразность А\В
	for (int i = 0; i < num_A; i++) { //прогоняем по длине А
		for (int j = 0; j < num_B; j++) { //прогоняем по длине В
			if ((A[i][0] == B[j][0]) && (A[i][1] == B[j][1])) { //если первй элемент равен первому, а второй - второму
				flag = false; //делаем флаг ложным
				break; //оканчиваем перебор В и берем след пару А
			}
			else { //если иначи
				flag = true; //делаем флаг истинным
				continue; //продолжаем перебор
			}
		}
		if (flag) { //если в конце флаг истинный
			cout << A[i][0] << " " << A[i][1] << endl; // выводим пару графика А
		}
	}

	//СИММЕТРИЧЕСКАЯ РАЗНОСТЬ
	cout << "-------------------СИММЕТРИЧЕСКАЯ РАЗНОСТЬ-----------------\n";
	int** S_R = new int* [1];//создаем график под симметрическую разность
	for (int i = 0; i < num_B; i++) { //прогоняем по длине В
		for (int j = 0; j < num_A; j++) { //прогоняем по длине А
			if ((B[i][0] == A[j][0]) && (B[i][1] == A[j][1])) { //если первый элемент равен первому, а второй - второму
				flag = false; //делаем флаг ложным
				break; //оканчиваем перебор А и берем след пару В
			}
			else { //если иначе
				flag = true; //делаем флаг истинным
				continue; //продолжаем перебор
			}
		}
		if (flag) { //если в конце флаг истинный
			cout << B[i][0] << " " << B[i][1] << endl; //выводим пару графика В
		}
	}
	for (int i = 0; i < num_A; i++) { //прогоняем по длине А
		for (int j = 0; j < num_B; j++) { //прогоняем по длине В
			if ((A[i][0] == B[j][0]) && (A[i][1] == B[j][1])) { //если первый элемент равен первому, а второй - второму
				flag = false; //делаем флаг ложным
				break; //оканчиваем перебор В и берем след пару А
			}
			else { //если иначе
				flag = true; //делаем флаг истинным
				continue; //продолжаем перебор
			}
		}
		if (flag) { //если в конце флаг истинный
			cout << A[i][0] << " " << A[i][1] << endl; //выводим пару графика А
		}
	}

	//ИНВЕРСИЯ А
	cout << "-----------------ИНВЕРСИЯ А--------------\n";
	for (int i = 0; i < num_A; i++) { //прогоняем по длине А
		cout << A[i][1] << " " << A[i][0] << endl; //меняем местами первый и второй элемент пары и выводим
	}

	//ИНВЕРСИЯ B
	cout << "-----------------ИНВЕРСИЯ B--------------\n";
	for (int i = 0; i < num_B; i++) { //прогоняем по длине В
		cout << B[i][1] << " " << B[i][0] << endl; //меняем местами первый и второй элемент пары и выводим
	}

	//КОМПОЗИЦИЯ А*В
	cout << "-----------КОМПОЗИЦИЯ А*В-------------\n";
	int** K1 = new int* [10000]; //создаем график под композицию А*В
	for (int i = 0; i < 10000; i++) {
		K1[i] = new int[2];
	}
	int num = 0;
	for (int i = 0; i < num_A; i++) { //прогоняем по длине А
		for (int j = 0; j < num_B; j++) { //прогоняем по длине В
			flag = true;
			if (A[i][1] == B[j][0]) { //если второй элемент А равен первому элементу В
				for (int m = 0; m <= num; m++) {
					if ((K1[m][0] == A[i][0]) && (K1[m][1] == B[j][1])) {
						flag = false;
						break;
					}
				}
				if (flag) {
					K1[num][0] = A[i][0];
					K1[num][1] = B[j][1];
					num++;
					cout << A[i][0] << " " << B[j][1] << endl; //выводим пару с первым элементом от А и вторым от В
				}
				continue; //продолжаем перебор
			}
		}
	}

	//КОМПОЗИЦИЯ B*A
	cout << "-----------КОМПОЗИЦИЯ B*A-------------\n";
	int** K2 = new int* [10000]; //создаем график под композицию В*А
	for (int i = 0; i < 10000; i++) {
		K2[i] = new int[2];
	}
	num = 0;
	for (int i = 0; i < num_B; i++) { //прогоняем по длине В
		for (int j = 0; j < num_A; j++) { //прогоняем по длине А
			flag = true;
			if (B[i][1] == A[j][0]) { //если второй элемент В равен первому элементу А
				for (int m = 0; m <= num; m++) {
					if ((K2[m][0] == A[i][0]) && (K2[m][1] == B[j][1])) {
						flag = false;
						break;
					}
				}
				if (flag) {
					K2[num][0] = A[i][0];
					K2[num][1] = B[j][1];
					num++;
					cout << B[i][0] << " " << A[j][1] << endl; //выводим пару с первым элементом от В и вторым от А
				}
				continue; //продолжаем перебор
			}
		}
	}

	//ДОПОЛНЕНИЕ А
	cout << "-----------ДОПОЛНЕНИЕ А-------------\n";
	flag = false; //делаем флаг ложным
	int** Dop_1 = new int* [10000]; //создаем график под дополнение А
	for (int i = 0; i < 10000; i++) { //прогоняем по длине универсума
		for (int j = 0; j < num_A; j++) { //одновременно прогоняем по длине А
			if ((Un[i][0] == A[j][0]) && (Un[i][1] == A[j][1])) { //если первый элемент равен первому, а второй - второму
				flag = false; //делаем флаг ложным
				break; //оканчиваем перебор А и берем след пару универсума
			}
			else { //если иначе 
				flag = true; //делаем флаг истинным
			}
		}
		if (flag) { //если флаг истинный
			cout << Un[i][0] << " " << Un[i][1] << " | "; //выводим пару универсума
		}
	}
	cout << endl;

	//ДОПОЛНЕНИЕ В
	cout << "-----------ДОПОЛНЕНИЕ В-------------\n";
	flag = false; //делаем флаг ложным
	int** Dop_2 = new int* [10000]; //создаем график под дополнение В
	for (int i = 0; i < 10000; i++) { //прогоняем по длине универсума
		for (int j = 0; j < num_B; j++) { //прогоняем по длине В
			if ((Un[i][0] == B[j][0]) && (Un[i][1] == B[j][1])) { //если первый элемент равен первому, а второй - второму
				flag = false; //делаем флаг ложным
				break; //оканчиваем перебор В и берем след пару универсума
			}
			else { //если иначе
				flag = true; //делаем флаг истинным
			}
		}
		if (flag) { //если флаг истинный
			cout << Un[i][0] << " " << Un[i][1] << " | "; //выводим пару универсума
		}
	}
	return 0; //конец программы
}